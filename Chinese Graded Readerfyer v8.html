<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chinese Graded Reader-fyer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* 2. Custom styles for annotation and printing */
        body {
            font-family: 'Inter', system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, 'Noto Sans', sans-serif;
        }
        .unknown-char {
            background-color: #fef9c3; /* Tailwind 'yellow-100' */
            color: #713f12; /* Tailwind 'yellow-900' */
            border-radius: 3px;
            padding: 0 2px;
            text-decoration: none;
            cursor: help;
        }
        .unknown-ref {
            vertical-align: super;
            font-size: 0.75em;
            line-height: 1;
            margin-left: 1px;
            color: #dc2626; /* Tailwind 'red-600' */
            font-weight: bold;
            text-decoration: none;
        }
        .loader {
            border: 4px solid #f3f3f3; /* Light grey */
            border-top: 4px solid #3498db; /* Blue */
            border-radius: 50%;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
            display: inline-block;
            margin-right: 10px;
            vertical-align: middle;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* PRINT STYLES (Includes Column Fix) */
        @media print {
            #input-section, #process-btn, #print-btn { display: none !important; }
            #output-section { width: 100% !important; padding: 0 !important; margin: 0 !important; border: none !important; }
            #progress-section { display: none !important; }
            #level-select-group { display: none !important; } 
            
            .unknown-char { background-color: #fef9c3 !important; color: #000 !important; -webkit-print-color-adjust: exact; print-adjust: exact; }
            a { text-decoration: none !important; color: inherit !important; }
            
            #annotated-text { font-size: 12pt; line-height: 1.5; }
            h2 { font-size: 16pt !important; padding-top: 1rem; }

            /* Two-Column Glossary Layout */
            #glossary-list {
                list-style: decimal !important;
                margin-left: 2em !important;
                page-break-before: auto;
                font-size: 10pt;
                column-count: 2;
                column-gap: 2.5rem;
            }
            #glossary-list li {
                -webkit-column-break-inside: avoid;
                page-break-inside: avoid;
                break-inside: avoid;
                padding-bottom: 8px;
            }
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800">

    <div class="max-w-7xl mx-auto p-6 md:p-10">
        <h1 class="text-3xl font-bold text-center mb-8 text-gray-900">Chinese Graded Reader-fyer</h1>

        <div id="input-section" class="grid md:grid-cols-2 gap-6 mb-6">
            <div class="bg-white p-6 rounded-lg shadow">
                <label for="known-chars" class="block text-lg font-semibold mb-2">1. Known Words/Characters</label>
                <p class="text-sm text-gray-600 mb-4">Saved list of known items (one per line).</p>

                <div id="level-select-group">
                    <label for="level-select" class="block text-sm font-medium text-gray-700 mb-1 mt-4">Set Known Words to Level:</label>
                    <select id="level-select" class="w-full p-2 mb-3 border border-gray-300 rounded-md bg-gray-50 focus:ring-2 focus:ring-blue-500">
                        <option value="">-- Select a level to load --</option>
                        <option value="level1">Level 1 (Base)</option>
                        <option value="level2">Level 2 (Cumulative)</option>
                        </select>
                </div>

                <textarea id="known-chars" rows="10" class="w-full p-3 border border-gray-300 rounded-md focus:ring-2 focus:ring-blue-500" placeholder="Loading repository..."></textarea>
            </div>
            
            <div class="bg-white p-6 rounded-lg shadow">
                <label for="input-text" class="block text-lg font-semibold mb-2">2. Text to Analyze</label>
                <p class="text-sm text-gray-600 mb-4">Paste the full Chinese text you want to read here. (New words will be highlighted.)</p>
                <textarea id="input-text" rows="10" class="w-full p-3 border border-gray-300 rounded-md focus:ring-2 focus:ring-blue-500" placeholder="ä»Šå¤©å¤©æ°”å¾ˆå¥½ï¼Œæˆ‘ä»¬åŽ»å…¬å›­çŽ©å„¿å§ã€‚"></textarea>
            </div>
        </div>

        <div class="text-center mb-8">
            <button id="process-btn" class="bg-blue-600 text-white font-bold py-3 px-8 rounded-lg shadow-md hover:bg-blue-700 transition duration-300 text-lg flex items-center justify-center w-64 mx-auto disabled:opacity-75" style="min-height: 60px;" disabled>
                <span class="loader"></span>
                Loading Repository...
            </button>
        </div>

        <div id="output-section" class="bg-white p-6 md:p-10 rounded-lg shadow-lg hidden">
            <button id="print-btn" onclick="window.print()" class="float-right -mt-4 bg-gray-700 text-white font-semibold py-2 px-5 rounded-md hover:bg-gray-800 transition">
                Save as PDF
            </button>
            
            <h2 class="text-2xl font-bold mb-6 border-b pb-3">Analyzed Text</h2>

            <div id="progress-section" class="mb-8 bg-blue-50 p-4 rounded-lg border border-blue-100">
                <div class="flex justify-between mb-2">
                    <span class="text-sm font-medium text-blue-700" id="progress-text">Knowledge Coverage</span>
                    <span class="text-sm font-medium text-blue-700" id="progress-percent">0%</span>
                </div>
                <div class="w-full bg-blue-200 rounded-full h-4">
                    <div id="progress-bar" class="bg-blue-600 h-4 rounded-full transition-all duration-1000 ease-out" style="width: 0%"></div>
                </div>
                <p id="progress-details" class="text-xs text-blue-600 mt-2 text-center">
                    </p>
            </div>
            <div id="annotated-text" class="text-lg leading-relaxed whitespace-pre-wrap">
                </div>

            <h2 class="text-2xl font-bold mt-12 mb-6 border-b pb-3">Unknown Word Glossary</h2>
            <p class="text-sm text-gray-600 mb-4">A list of all unknown words/characters found in the text, in order of appearance. Definitions come from the **embedded dictionary**.</p>
            <ol id="glossary-list" class="list-decimal list-inside space-y-4">
                </ol>
        </div>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, onSnapshot, setDoc, setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        const FULL_EMBEDDED_DICTIONARY = {
            "ä½ å¥½": { pinyin: "nÇ hÇŽo", definition: "hello" },
            "å¤©æ°”": { pinyin: "tiÄn qÃ¬", definition: "weather" },
            "å…¬å›­": { pinyin: "gÅng yuÃ¡n", definition: "park" },
            "ä»Šå¤©": { pinyin: "jÄ«n tiÄn", definition: "today" },
            "å¾ˆå¥½": { pinyin: "hÄ›n hÇŽo", definition: "very good" },
            "æˆ‘ä»¬": { pinyin: "wÇ’ men", definition: "we, us" },
            "çŽ©å„¿": { pinyin: "wÃ¡nr", definition: "to play" },
            "å§": { pinyin: "ba", definition: "modal particle" },
            "å¾ˆ": { pinyin: "hÄ›n", definition: "very" },
            "å¥½": { pinyin: "hÇŽo", definition: "good" },
            "å¤©": { pinyin: "tiÄn", definition: "day, sky" },
            "æ°”": { pinyin: "qÃ¬", definition: "air, gas" },
            "æˆ‘": { pinyin: "wÇ’", definition: "I, me" },
            "ä½ ": { pinyin: "nÇ", definition: "you" },
            "å—": { pinyin: "ma", definition: "question particle" },
            "ä»–": { pinyin: "tÄ", definition: "he, him" },
            "å¥¹": { pinyin: "tÄ", definition: "she, her" },
            "ä»¬": { pinyin: "men", definition: "plural marker" },
            "è§": { pinyin: "jiÃ n", definition: "to see" },
            "å†è§": { pinyin: "zÃ ijiÃ n", definition: "goodbye" },
            "ä¸": { pinyin: "bÃ¹", definition: "not" },
            "çˆ¸çˆ¸": { pinyin: "bÃ ba", definition: "dad" },
            "å¦ˆå¦ˆ": { pinyin: "mÄma", definition: "mom" },
            "å“¥å“¥": { pinyin: "gÄ“ge", definition: "older brother" },
            "å§å§": { pinyin: "jiÄ›jie", definition: "older sister" },
            "å–œæ¬¢": { pinyin: "xÇhuan", definition: "to like" },
            "åƒ": { pinyin: "chÄ«", definition: "to eat" },
            "å–": { pinyin: "hÄ“", definition: "to drink" },
            "æ°´": { pinyin: "shuÇ", definition: "water" },
            "åå­—": { pinyin: "mÃ­ngzi", definition: "name" },
            "å®¿": { pinyin: ["su4"], definition: "old variant of å®¿[su4]"},
            "å†¥": { pinyin: ["ming2"], definition: "old variant of å†¥[ming2]"},
            "æœ€": { pinyin: ["zui4"], definition: "variant of æœ€[zui4]"},
            "ä¸€ä¸ªå·´æŽŒæ‹ä¸å“": { pinyin: ["yi1 ge5 ba1 zhang3 pai1 bu4 xiang3"], definition: "lit. one palm alone cannot clap (proverb)/fig. it takes two persons to start a dispute/it takes two to tango/it's difficult to achieve anything without support"},
            "é¿¬": { pinyin: ["tian2"], definition: "tennessine (chemistry)" }
        };

        const DICTIONARY_KEYS_SORTED = Object.keys(FULL_EMBEDDED_DICTIONARY).sort((a, b) => b.length - a.length);

        // =================================================
        // === HUGE WORD LISTS DEFINITION (Cumulative) ===
        // =================================================
        
        // 1. Define Level 1 words here using backticks (`)
        const LEVEL_1_BASE = `
ä½  å¥½ å— æˆ‘ ä»– å¥¹ ä»¬ å§ è§ å†è§ ä¸
è¿™é‡Œ é‚£é‡Œ å“ªé‡Œ è° ä»€ä¹ˆ æ—¶å€™ æ€Žä¹ˆ æ€Žä¹ˆæ ·
`;

        // 2. Define ONLY the NEW words for Level 2 here
        const LEVEL_2_ADDITIONS = `
çˆ¸çˆ¸ å¦ˆå¦ˆ å“¥å“¥ å§å§ å–œæ¬¢ åƒ å– æ°´ åå­—
è€å¸ˆ å­¦ç”Ÿ å­¦æ ¡ åŒå­¦ æœ‹å‹ åŒ»ç”Ÿ åŒ»é™¢ å•†åº—
`;

        // 3. Define ONLY the NEW words for Level 3 here (Example)
        // const LEVEL_3_ADDITIONS = ` ... words ... `;


        // === LOGIC TO COMBINE THEM ===
        const PRESET_WORD_LISTS = {
            "level1": LEVEL_1_BASE,
            
            // This automatically joins Level 1 + Level 2 additions
            "level2": LEVEL_1_BASE + " " + LEVEL_2_ADDITIONS 
            
            // "level3": LEVEL_1_BASE + " " + LEVEL_2_ADDITIONS + " " + LEVEL_3_ADDITIONS
        };
        // =================================================

        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        let db, auth, userId = null;
        let firestoreKnownSet = new Set();
        const KNOWN_CHARS_INPUT = document.getElementById('known-chars');
        const INPUT_TEXT = document.getElementById('input-text');
        const PROCESS_BTN = document.getElementById('process-btn');
        const OUTPUT_SECTION = document.getElementById('output-section');
        const ANNOTATED_TEXT_DIV = document.getElementById('annotated-text');
        const GLOSSARY_LIST = document.getElementById('glossary-list');
        const LEVEL_SELECT = document.getElementById('level-select'); 

        const KNOWN_CHARACTERS_COLLECTION = 'chinese_repository';
        const KNOWN_CHARACTERS_DOC_ID = 'known_list';

        function getUserDocRef() {
            if (!db || !userId) return null;
            return doc(db, 'artifacts', appId, 'users', userId, KNOWN_CHARACTERS_COLLECTION, KNOWN_CHARACTERS_DOC_ID);
        }

        function setupRealtimeListener() {
            const docRef = getUserDocRef();
            if (!docRef) {
                console.error("No DocRef. Fallback to local input.");
                PROCESS_BTN.disabled = false;
                PROCESS_BTN.innerHTML = 'Analyze Text';
                KNOWN_CHARS_INPUT.placeholder = 'Could not load repository. Using local input only.';
                return;
            }

            onSnapshot(docRef, (doc) => {
                let knownCharsString = '';
                if (doc.exists()) {
                    const data = doc.data();
                    knownCharsString = data.knownCharacters || '';
                }
                const knownItems = knownCharsString.split(/[\s\n,]+/).filter(Boolean);
                firestoreKnownSet = new Set(knownItems);
                
                if (KNOWN_CHARS_INPUT.placeholder === 'Loading repository...') {
                     KNOWN_CHARS_INPUT.value = Array.from(firestoreKnownSet).join('\n');
                     KNOWN_CHARS_INPUT.placeholder = 'Paste all your known words and characters here (one per line)...';
                }

                PROCESS_BTN.disabled = false;
                PROCESS_BTN.innerHTML = 'Analyze Text';
                PROCESS_BTN.querySelector('.loader').style.display = 'none';
            }, (error) => {
                console.error("Error loading repository from database:", error);
                PROCESS_BTN.disabled = false;
                PROCESS_BTN.innerHTML = 'Analyze Text (Repo Error)';
                PROCESS_BTN.querySelector('.loader').style.display = 'none';
                KNOWN_CHARS_INPUT.placeholder = 'Error loading persistent data. Using local input only.';
            });
        }
        
        async function saveKnownCharacters(knownCharsString) {
            const docRef = getUserDocRef();
            if (!docRef) {
                console.error("Cannot save: Database not initialized or User ID missing.");
                return;
            }
            try {
                await setDoc(docRef, { knownCharacters: knownCharsString });
            } catch (error) {
                console.error("Failed to save known characters:", error);
            }
        }

        function getDefinition(item) {
            if (FULL_EMBEDDED_DICTIONARY.hasOwnProperty(item)) {
                const entry = FULL_EMBEDDED_DICTIONARY[item];
                const pinyin = Array.isArray(entry.pinyin) ? entry.pinyin.join(', ') : entry.pinyin;
                return {
                    pinyin: pinyin,
                    definition: entry.definition
                };
            }
            return {
                pinyin: "??",
                definition: "Definition not found in the local dictionary."
            };
        }

        PROCESS_BTN.addEventListener('click', async () => {
            PROCESS_BTN.disabled = true;
            PROCESS_BTN.innerHTML = '<span class="loader"></span> Processing...';
            OUTPUT_SECTION.classList.add('hidden');
            ANNOTATED_TEXT_DIV.innerHTML = '';
            GLOSSARY_LIST.innerHTML = '';

            const inputText = INPUT_TEXT.value;
            const knownCharsInput = KNOWN_CHARS_INPUT.value;

            // 1. Get current known set
            const currentKnownItems = new Set(knownCharsInput.split(/[\s\n,]+/).filter(Boolean));
            
            let annotatedHtml = '';
            const glossary = [];
            const glossaryIndexMap = new Map();
            const newItemsFound = new Set();
            let glossaryIndexCounter = 1; 
            let i = 0;

            // 2. Iterate through the text (Main Annotation Loop)
            while (i < inputText.length) {
                const char = inputText[i];

                if (char === '\n') {
                    annotatedHtml += '<br>';
                    i++;
                    continue;
                }
                if (!char.match(/[\u4e00-\u9fff]/)) {
                    annotatedHtml += char;
                    i++;
                    continue;
                }

                // 3. Maximal Match
                let matchFound = false;
                for (const key of DICTIONARY_KEYS_SORTED) {
                    if (inputText.startsWith(key, i)) {
                        matchFound = true;
                        if (!currentKnownItems.has(key)) {
                            // UNKNOWN word
                            const def = getDefinition(key);
                            let refIndex;
                            if (glossaryIndexMap.has(key)) {
                                refIndex = glossaryIndexMap.get(key);
                            } else {
                                refIndex = glossaryIndexCounter++;
                                glossaryIndexMap.set(key, refIndex);
                                glossary.push({ item: key, index: refIndex, pinyin: def.pinyin, definition: def.definition });
                            }
                            newItemsFound.add(key);
                            annotatedHtml += `<a href="#g${refIndex}" class="unknown-char" title="${key} (${def.pinyin}): ${def.definition}">` +
                                             `${key}` + 
                                             `<sup id="t${refIndex}" class="unknown-ref"> ${refIndex}</sup>` +
                                             `</a>`;
                        } else {
                            // KNOWN word
                            annotatedHtml += key;
                        }
                        i += key.length;
                        break;
                    }
                }

                // 5. Fallback
                if (!matchFound) {
                    const singleChar = inputText[i];
                    if (!currentKnownItems.has(singleChar)) {
                        // UNKNOWN single char
                        const def = getDefinition(singleChar);
                        let refIndex;
                        if (glossaryIndexMap.has(singleChar)) {
                            refIndex = glossaryIndexMap.get(singleChar);
                        } else {
                            refIndex = glossaryIndexCounter++;
                            glossaryIndexMap.set(singleChar, refIndex);
                            glossary.push({ item: singleChar, index: refIndex, pinyin: def.pinyin, definition: def.definition });
                        }
                        newItemsFound.add(singleChar);
                        annotatedHtml += `<a href="#g${refIndex}" class="unknown-char" title="${singleChar} (${def.pinyin}): ${def.definition}">` +
                                         `${singleChar}` + 
                                         `<sup id="t${refIndex}" class="unknown-ref"> ${refIndex}</sup>` +
                                         `</a>`;
                    } else {
                        // KNOWN single char
                        annotatedHtml += singleChar;
                    }
                    i++;
                }
            } // End of while-loop (text processing)

            
            // --- Progress Bar Calculation ---
            let totalMeaningfulItems = 0;
            let knownItemsCount = 0;
            let j = 0;
            while (j < inputText.length) {
                const char = inputText[j];
                if (!char.match(/[\u4e00-\u9fff]/)) { j++; continue; }
                let itemFound = false;
                for (const key of DICTIONARY_KEYS_SORTED) {
                    if (inputText.startsWith(key, j)) {
                        totalMeaningfulItems++;
                        if (currentKnownItems.has(key)) {
                            knownItemsCount++;
                        }
                        j += key.length;
                        itemFound = true;
                        break;
                    }
                }
                if (!itemFound) {
                    totalMeaningfulItems++;
                    if (currentKnownItems.has(inputText[j])) {
                        knownItemsCount++;
                    }
                    j++;
                }
            }
            const coveragePercent = totalMeaningfulItems > 0 ? Math.round((knownItemsCount / totalMeaningfulItems) * 100) : 0;
            requestAnimationFrame(() => {
                document.getElementById('progress-bar').style.width = `${coveragePercent}%`;
            });
            document.getElementById('progress-percent').textContent = `${coveragePercent}%`;
            document.getElementById('progress-text').textContent = `You know ${coveragePercent}% of this text!`;
            document.getElementById('progress-details').textContent = `You know ${knownItemsCount} out of ${totalMeaningfulItems} total words/characters.`;
            
            // 6. Inject annotated text
            ANNOTATED_TEXT_DIV.innerHTML = annotatedHtml;

            // 7. Inject glossary
            if (glossary.length === 0) {
                GLOSSARY_LIST.innerHTML = '<li class="text-gray-600">No unknown words or characters found! ðŸŽ‰</li>';
            } else {
                glossary.sort((a, b) => a.index - b.index);
                
                GLOSSARY_LIST.innerHTML = glossary.map(item => `
                    <li id="g${item.index}" class="p-3 bg-gray-50 rounded-md hover:bg-gray-100 transition duration-150">
                        <span class="text-red-600 font-bold mr-2">(${item.index})</span>
                        <span class="text-2xl font-serif text-gray-900 mr-4">${item.item}</span> 
                        <span class="font-semibold text-blue-700 mr-2">${item.pinyin}</span>:
                        ${item.definition}
                        <a href="#t${item.index}" class="text-xs text-gray-500 float-right hover:text-gray-700 transition">Jump to Text</a>
                    </li>
                `).join('');
            }

            // 8. Update the Known Characters list (this part from your code stops auto-add)
            const allKnownItems = Array.from(currentKnownItems);
            const newKnownItemsString = allKnownItems.join('\n');
            KNOWN_CHARS_INPUT.value = newKnownItemsString;
            
            // 9. Save the updated repository to Firestore
            await saveKnownCharacters(newKnownItemsString);

            // 10. Display output and reset button
            OUTPUT_SECTION.classList.remove('hidden');
            PROCESS_BTN.disabled = false;
            PROCESS_BTN.innerHTML = 'Analyze Text';
        });

        // ===================================
        // === REPLACEMENT LOGIC (CUMULATIVE) ===
        // ===================================
        LEVEL_SELECT.addEventListener('change', async (e) => {
            const selectedLevel = e.target.value;
            if (!selectedLevel) return; 

            const newWordsString = PRESET_WORD_LISTS[selectedLevel];
            if (!newWordsString) {
                console.error("No word list found for:", selectedLevel);
                return;
            }

            // 1. Get new words from the preset list
            const newWordsArray = newWordsString.split(/[\s\n,]+/); // Split by any whitespace

            // 2. Format them with newlines
            const replacementString = newWordsArray.filter(Boolean).join('\n');

            // 3. Update the textarea
            KNOWN_CHARS_INPUT.value = replacementString;

            // 4. Save to the database
            await saveKnownCharacters(replacementString);

            // 5. We keep the selection visible (reset line removed)
        });
        // ===================================
        // === END ===
        // ===================================


        // --- Firebase Initialization (Unchanged) ---
        async function initializeFirebase() {
            try {
                // setLogLevel('debug');

                if (!firebaseConfig || !firebaseConfig.apiKey) {
                    console.error("Firebase configuration is missing or incomplete.");
                    KNOWN_CHARS_INPUT.value = 'Cannot connect to database. Please use local input only.';
                    KNOWN_CHARS_INPUT.disabled = false;
                    PROCESS_BTN.disabled = false;
                    PROCESS_BTN.innerHTML = 'Analyze Text';
                    PROCESS_BTN.querySelector('.loader').style.display = 'none';
                    return;
                }
                
                const app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);

                if (initialAuthToken) {
                    await signInWithCustomToken(auth, initialAuthToken);
                } else {
                    await signInAnonymously(auth);
                }

                onAuthStateChanged(auth, (user) => {
                    if (user) {
                        userId = user.uid;
                        setupRealtimeListener();
                    } else {
                        userId = crypto.randomUUID();
                        console.warn("Signed in anonymously or using fallback ID:", userId);
                        setupRealtimeListener();
                    }
                });
            } catch (error) { 
                console.error("Firebase initialization failed:", error);
                KNOWN_CHARS_INPUT.value = 'Paste your known characters here.';
                PROCESS_BTN.disabled = false;
                PROCESS_BTN.innerHTML = 'Analyze Text';
                PROCESS_BTN.querySelector('.loader').style.display = 'none';
            }
        }

        document.addEventListener('DOMContentLoaded', initializeFirebase);
    </script>
</body>
</html>